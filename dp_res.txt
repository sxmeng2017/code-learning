动态规划问题是算法问题的常客，它能解决大多数搜寻问题，下面为LeetCode上部分dp算法题目的总结
121.best time to buy and sell stock
这题留一个空间记录最大差值就行，注意两个位置，之前所有位置的最小值，和所有差值中的最小值，后者需要前者存在
746 .Min Cost Climbing Stairs
这题因为一次可以走两个，也可以走一个阶梯，所以，最后结果和前一个，前两个有关将前一个和前两个的最小花费和当前花费相加就可以得到当前位置的花费。
53.Maximum Subarray
比较当前子数组的和与当前值的大小，如果比当前值还小就记录当前值，这样就可以保证前面出现较大负数时不会影响到后面。
198.House Robber
抢劫当前房屋需要比较前一个和前两个与当前房屋收获的和，这样就能得到递关系
413.Arithmetic Slices
这题的问题在两次递推，数列的递推和数列个数的和的递推，同样给出子数列长度加一意味在原数列基础上还有其1倍加1个，然后和为每个位置的和。写出递推关系
综上，dp问题的关键在起点，从什么值开始计算，以及递推关系。这两个确定好即可解决dp问题。
dp方法对于解决组合的解的数量问题具有较好适用，但不能解决这些组合是那些的问题
